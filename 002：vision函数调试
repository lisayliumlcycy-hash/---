from enum import Enum
from collections import namedtuple

import cv2
import numpy as np

# --- 1. CONFIGURATION (Optimized for Speed) ---

# å›¾åƒå°ºå¯¸ (å·²é™ä½åˆ†è¾¨ç‡ä»¥æé«˜é€Ÿåº¦)
width, height = 320, 240

# ğŸ¯ å‡†ç¡®é˜ˆå€¼ (æ ¹æ®ç”¨æˆ·è°ƒè¯•ç»“æœç¡®å®š)
DEFAULT_WHITE_THRESHOLD = 109 
DEFAULT_BLACK_THRESHOLD = 120 
DEFAULT_CUT_MARGIN = 0 

# é¢œè‰²å¸¸é‡ (å·²æ›´æ–°)
YELLOW_LOWER = (26, 0, 0)
YELLOW_UPPER = (46, 255, 255)

# æ£‹ç›˜è§’ç‚¹é¢œè‰²æ©ç  (Red, Green, Blue, Purple)
CORNER_MASKS_HSV = [
    ((0, 140, 102), (15, 255, 255)),     # 0: çº¢è‰²
    ((62, 75, 50), (82, 255, 255)),      # 1: ç»¿è‰²
    ((96, 140, 95), (116, 255, 255)),    # 2: è“è‰² (Updated)
    ((125, 50, 50), (145, 255, 255)),    # 3: ç´«è‰²
]

# --- 2. BASE CLASSES AND EXCEPTIONS ---

Point = namedtuple("Point", ["x", "y"])

class Colors(Enum):
    white = (255, 255, 255)
    black = (0, 0, 0)
    blue = (255, 0, 0)
    green = (0, 255, 0)
    red = (0, 0, 255)

class SquareType(Enum):
    empty = 0
    white = 1
    black = 2

    def __str__(self):
        if self == SquareType.empty:
            return ' '
        if self == SquareType.white:
            return 'o'
        if self == SquareType.black:
            return 'x'
        return None

class ChessboardNotFoundError(Exception):
    """å½“æ— æ³•æ‰¾åˆ°æ£‹ç›˜è§’ç‚¹æ—¶å¼•å‘æ­¤å¼‚å¸¸"""
    pass

# --- 3. HELPER FUNCTIONS (Function names are preserved) ---

def _clean_mask(mask, kernel_size=(5, 5)):
    """ä½¿ç”¨å½¢æ€å­¦æ“ä½œæ¸…ç†æ©ç """
    kernel = np.ones(kernel_size, np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel) 
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
    return mask

def _threshold_image(image):
    """å¯¹å›¾åƒè¿›è¡Œæ¨¡ç³Šå’ŒäºŒå€¼åŒ–"""
    blurred = cv2.blur(image, (10, 10))
    _, thresholded = cv2.threshold(blurred, 200, 255, cv2.THRESH_BINARY)
    return thresholded

def _find_point(image):
    """ä»æœ€å¤§è½®å»“ä¸­æå–ä¸­å¿ƒç‚¹"""
    def center(contour):
        x, y, w, h = cv2.boundingRect(contour)
        return Point(x + w // 2, y + h // 2)

    try:
        # OpenCV 4.x returns two values
        contours, _ = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    except:
        # OpenCV 3.x returns three values
        _, contours, _ = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if len(contours) < 1:
        return None
    contour = max(contours, key=cv2.contourArea)
    return center(contour)

# Returns the four corners of the chessboard, or None if not found.
def find_corners(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    
    # åˆ›å»ºè§’ç‚¹é¢œè‰²æ©ç 
    masks = [cv2.inRange(hsv, lower, upper) for lower, upper in CORNER_MASKS_HSV]
    
    # æŸ¥æ‰¾æ¯ä¸ªæ©ç å¯¹åº”çš„ä¸­å¿ƒç‚¹
    points = [_find_point(_threshold_image(_clean_mask(mask))) for mask in masks]

    if not all(points):
        return None

    # ä» Point å¯¹è±¡ä¸­æå–åæ ‡
    x0, y0 = points[0]
    x1, y1 = points[1]
    x2, y2 = points[2]
    x3, y3 = points[3]

    # åº”ç”¨å¾®è°ƒä»¥ä¿®æ­£æ ‡è®°å’Œæ£‹ç›˜è¾¹ç¼˜çš„åå·®
    adjusted_points = [
        Point(int(x0 + (x0 - x1) * 0.00 - (x0 - x2) * 0.05), int(y0 + (y0 - y1) * 0.00 - (y0 - y2) * 0.05)),
        Point(int(x1 + (x1 - x0) * 0.08 - (x1 - x3) * 0.05), int(y1 + (y1 - y0) * 0.08 - (y1 - y3) * 0.05)),
        Point(int(x2 + (x2 - x3) * 0.02 - (x2 - x0) * 0.05), int(y2 + (y2 - y3) * 0.02 - (y2 - y0) * 0.05)),
        Point(int(x3 + (x3 - x2) * 0.08 - (x3 - x1) * 0.05), int(y3 + (y3 - y2) * 0.08 - (y3 - y1) * 0.05)),
    ]
    return adjusted_points


# Returns a new image after a perspective transform,
# moving [corners] to the corners of the image.
def transform(image, corners):
    src = np.array(
        [(corners[0].x, corners[0].y), (corners[1].x, corners[1].y), (corners[2].x, corners[2].y), (corners[3].x, corners[3].y)], np.float32)

    dst = np.array(
        [(0, 0), (width, 0), (0, height), (width, height)], np.float32)

    matrix = cv2.getPerspectiveTransform(src, dst)
    return cv2.warpPerspective(image, matrix, (width, height))


# Return the square type of the given of image.
def detect_square_type(image_gray, image_hsv):
    """
    ä½¿ç”¨é¢„è½¬æ¢çš„ç°åº¦å›¾å’ŒHSVå›¾å¿«é€Ÿè¯†åˆ«æ£‹æ ¼ç±»å‹ã€‚
    è¿™æ˜¯æˆ‘ä»¬ä¸ºæ€§èƒ½ä¼˜åŒ–çš„ç‰ˆæœ¬ã€‚
    æ³¨æ„ï¼šæ­¤å‡½æ•°ç­¾åä¸åŸæ¨¡æ¿ä¸­åŸºäº Floodfill çš„ç‰ˆæœ¬ä¸åŒï¼Œä½†åŠŸèƒ½ç­‰ä»·ä¸”é€Ÿåº¦æ›´å¿«ã€‚
    """
    
    # ROI æˆªå–ï¼ˆä»…æˆªå–ä¸­å¿ƒ 40%ï¼‰
    h, w = image_gray.shape
    roi_gray = image_gray[int(h*0.3):int(h*0.7), int(w*0.3):int(w*0.7)] 
    roi_hsv = image_hsv[int(h*0.3):int(h*0.7), int(w*0.3):int(w*0.7)] 
    
    # 1. è®¡ç®—ç»Ÿè®¡é‡
    mean_val = np.mean(roi_gray) 
    square_type = SquareType.empty
    
    # 2. é¢œè‰²è¿‡æ»¤æ£€æµ‹ç©ºä½ (é»„è‰²èƒŒæ™¯)
    yellow_mask = cv2.inRange(roi_hsv, YELLOW_LOWER, YELLOW_UPPER)
    yellow_ratio = cv2.countNonZero(yellow_mask) / roi_gray.size
    
    if yellow_ratio > 0.50: 
        square_type = SquareType.empty
    
    # 3. äº®åº¦é˜ˆå€¼åŒºåˆ†æ£‹å­
    else:
        white_thresh = DEFAULT_WHITE_THRESHOLD
        black_thresh = DEFAULT_BLACK_THRESHOLD
            
        if mean_val > white_thresh: 
            square_type = SquareType.white
        elif mean_val < black_thresh:
            square_type = SquareType.black
        else:
            square_type = SquareType.empty 
            
    return square_type


# ------------------------------------------------------------------------------
# ğŸ¯ ä¸»å‡½æ•° GET_POSITION_FROM_IMAGE (å·²æ›´åä¸ºç”¨æˆ·è¦æ±‚çš„å‡½æ•°å)
# ------------------------------------------------------------------------------

def get_position_from_image(image):
    """
    è¯†åˆ«å›¾åƒä¸­çš„æ£‹ç›˜ï¼Œå¹¶è¿”å›å¯¹åº”çš„ 8x8 SquareType é˜µåˆ—ã€‚
    
    Args:
        image: åŸå§‹ OpenCV BGR å›¾åƒå¸§ã€‚
        
    Returns:
        list[list[SquareType]]: 8x8 æ£‹ç›˜çŠ¶æ€ã€‚
        
    Raises:
        ChessboardNotFoundError: å¦‚æœæ— æ³•æ‰¾åˆ°è§’ç‚¹ã€‚
    """
    
    # 1. è£å‰ªè¾…åŠ©å‡½æ•°
    def crop(image, i, j, margin_px): 
        w_sq = int(width / 8)
        h_sq = int(height / 8)
        
        x_start = w_sq * i
        x_end = w_sq * (i + 1)
        y_start = h_sq * j
        y_end = h_sq * (j + 1)
        
        return image[y_start + margin_px : y_end - margin_px, 
                     x_start + margin_px : x_end - margin_px]

    # 2. ç¼©æ”¾è¾“å…¥å›¾åƒåˆ°ç›®æ ‡å¤„ç†åˆ†è¾¨ç‡ (320x240)
    image = cv2.resize(image, (width, height))
    
    # 3. å¯»æ‰¾è§’ç‚¹å¹¶è¿›è¡Œé€è§†å˜æ¢
    corners = find_corners(image)
    if corners is None:
        raise ChessboardNotFoundError()

    chessboard_image = transform(image, corners)
    
    # 4. é¢„è½¬æ¢é¢œè‰²ç©ºé—´ (ä»…æ‰§è¡Œä¸¤æ¬¡ï¼Œæå‡æ€§èƒ½)
    chessboard_gray = cv2.cvtColor(chessboard_image, cv2.COLOR_BGR2GRAY)
    chessboard_hsv = cv2.cvtColor(chessboard_image, cv2.COLOR_BGR2HSV)
    
    margin_px = DEFAULT_CUT_MARGIN

    position = []
    
    # 5. éå† 8x8 æ£‹æ ¼å¹¶è¯†åˆ«
    for j in range(8):
        row = []
        for i in range(8):
            # è£å‰ª Gray å’Œ HSV å›¾åƒåˆ‡ç‰‡
            cropped_gray = crop(chessboard_gray, i, j, margin_px)
            cropped_hsv = crop(chessboard_hsv, i, j, margin_px)
            
            # ä¼ å…¥é¢„è½¬æ¢çš„åˆ‡ç‰‡è¿›è¡Œå¿«é€Ÿè¯†åˆ«
            square_type = detect_square_type(cropped_gray, cropped_hsv)
            
            row.append(square_type)

        position.append(row)

    return position


# ------------------------------------------------------------------------------
# ğŸ“¢ ç¤ºä¾‹ç”¨æ³• (ç”¨äºæµ‹è¯• get_position_from_image å‡½æ•°)
# ------------------------------------------------------------------------------

if __name__ == "__main__":
    CAMERA_INDEX = 1
    cap = cv2.VideoCapture(CAMERA_INDEX) 
    
    # å¿…é¡»è®¾ç½®æ‘„åƒå¤´æ•è·åˆ†è¾¨ç‡ä¸º get_position_from_image å‡½æ•°æ‰€æœŸæœ›çš„ (320x240)
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, width)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height)

    if not cap.isOpened():
        print(f"âŒ æ— æ³•æ‰“å¼€æ‘„åƒå¤´ (ç´¢å¼• {CAMERA_INDEX})ã€‚")
        exit()

    print(f"âœ… æ‘„åƒå¤´ç”»é¢ç¨³å®šï¼å¤„ç†åˆ†è¾¨ç‡: {width}x{height}")
    print("--- è¿è¡Œ get_position_from_image å‡½æ•° (ä½é€Ÿè¾“å‡ºæ¨¡å¼) ---")
    print("ä»…æ˜¾ç¤ºåŸå§‹å›¾åƒï¼Œå¹¶æ¯ 30 å¸§è¾“å‡ºä¸€æ¬¡æ£‹ç›˜ç»“æœã€‚æŒ‰ 'q' é”®é€€å‡ºã€‚")

    frame_counter = 0
    
    try:
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            
            cv2.imshow("0. Original Image (Resized to 320x240)", cv2.resize(frame, (width, height))) 

            if frame_counter % 30 == 0:
                try:
                    # è°ƒç”¨å·²æ›´åçš„ä¸»å‡½æ•°
                    position = get_position_from_image(frame)
                    
                    print("---")
                    for row in position:
                        row_str = "".join([str(p) for p in row])
                        print(row_str)
                    print("---")
                    
                except ChessboardNotFoundError:
                    # é¿å…åœ¨æ§åˆ¶å°é‡å¤æ‰“å°é”™è¯¯
                    pass 
                except Exception as e:
                    # æ•è·å…¶ä»–å¼‚å¸¸
                    pass
            
            frame_counter += 1

            key = cv2.waitKey(1)
            if key & 0xFF == ord('q'):
                break

    finally:
        cap.release()
        cv2.destroyAllWindows()
