# -*- coding: utf-8 -*-
import cv2
import numpy as np
import os

IMAGE_PATH = "002.jpg"                     # 你的照片
OUTPUT_FOLDER = "ChessBoard_64pieces"
width, height = 900, 900

def find_corners_ultra(img):
    img_lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)
    l, a, b = cv2.split(img_lab)
    l = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8,8)).apply(l)
    img = cv2.merge((l,a,b))
    img = cv2.cvtColor(img, cv2.COLOR_LAB2BGR)
    
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    masks = [
        cv2.inRange(hsv, (0, 80, 80), (20, 255, 255))   | cv2.inRange(hsv, (160, 80, 80), (180, 255, 255)),  # 红
        cv2.inRange(hsv, (35, 70, 70), (90, 255, 255)),    # 绿
        cv2.inRange(hsv, (90, 80, 80), (140, 255, 255)),   # 蓝
        cv2.inRange(hsv, (120, 50, 80), (179, 255, 255)),  # 粉/紫/黄
    ]
    
    points = []
    color_names = ["左上(红)", "右上(绿)", "左下(蓝)", "右下(粉)"]
    colors_bgr = [(0,0,255), (0,255,0), (255,0,0), (255,0,255)]
    
    for i, mask in enumerate(masks):
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (41,41))
        mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if not contours: return None
        c = max(contours, key=cv2.contourArea)
        M = cv2.moments(c)
        cx = int(M["m10"]/M["m00"])
        cy = int(M["m01"]/M["m00"])
        points.append((cx, cy))
        
        # 大圈 + 文字标注
        cv2.circle(img, (cx, cy), 80, colors_bgr[i], 15)
        cv2.putText(img, color_names[i], (cx-120, cy-100),
                   cv2.FONT_HERSHEY_SIMPLEX, 1.8, colors_bgr[i], 6)
    
    # 强制排序：左上 → 右上 → 左下 → 右下
    points = sorted(points, key=lambda p: (p[1]//(img.shape[0]//3), p[0]))
    top = sorted(points[:2], key=lambda p: p[0])
    bot = sorted(points[2:], key=lambda p: p[0])
    ordered = [top[0], top[1], bot[0], bot[1]]
    return ordered

def transform(img, corners):
    src = np.float32(corners)
    dst = np.float32([[0,0], [width,0], [0,height], [width,height]])
    M = cv2.getPerspectiveTransform(src, dst)
    warped = cv2.warpPerspective(img, M, (width, height))
    return warped, M  # 返回变换矩阵，方便后面画网格

# ==================== 主程序 ====================
img = cv2.imread(IMAGE_PATH)
if img is None:
    print("图片没找到！")
    exit()

print("正在找四个角标...")
corners = find_corners_ultra(img.copy())

if not corners:
    print("没找到四个角标！")
    cv2.imshow("失败", cv2.resize(img, (900,900)))
    cv2.waitKey(0)
    exit()

print("成功找到四个角标！顺序是：左上(红) → 右上(绿) → 左下(蓝) → 右下(粉)")

warped, M = transform(img, corners)

# 在校正后的棋盘上画 8×8 网格线（让你一眼看出对齐准不准）
grid = warped.copy()
cell_w, cell_h = width//8, height//8
for i in range(9):
    cv2.line(grid, (i*cell_w, 0), (i*cell_w, height), (0,255,255), 4)
    cv2.line(grid, (0, i*cell_h), (width, i*cell_h), (0,255,255), 4)

# 保存结果
desktop = os.path.join(os.path.expanduser("~"), "Desktop")
output_path = os.path.join(desktop, OUTPUT_FOLDER)
os.makedirs(output_path, exist_ok=True)

# 裁剪64个小格子（文件名 a8~h1）
files = "abcdefgh"
ranks = "87654321"
for y in range(8):
    for x in range(8):
        cell = warped[y*cell_h:(y+1)*cell_h, x*cell_w:(x+1)*cell_w]
        filename = f"{files[x]}{ranks[y]}.jpg"
        cv2.imwrite(os.path.join(output_path, filename), cell)

# 显示三张图让你彻底明白
cv2.imshow("1. 原图 + 四个角标已标注", cv2.resize(img, (900,900)))
cv2.imshow("2. 透视校正后纯棋盘", warped)
cv2.imshow("3. 校正后 + 黄色网格线（看对齐准不准）", cv2.resize(grid, (900,900)))

print("完美！64张小图已保存到桌面 ChessBoard_64pieces 文件夹")
print("左上角标=红色圆圈，右上=绿色，左下=蓝色，右下=粉色")
cv2.waitKey(0)
cv2.destroyAllWindows()
