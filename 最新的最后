import cv2
import time
import chess
import chess.engine
import os
import ipywidgets as widgets
from IPython.display import display, clear_output
from collections import namedtuple
from serial.tools import list_ports
from pydobot import Dobot

# å¯¼å…¥ä½ çš„è§†è§‰æ¨¡å—
from vision import get_position_from_image, SquareType, ChessboardNotFoundError, width, height

# --- 1. é…ç½® Stockfish è·¯å¾„ ---
SF_PATH = "/home/HwHiAiUser/_2400012735/stockfish/stockfish-android-armv8"
if os.path.exists(SF_PATH):
    os.chmod(SF_PATH, 0o755)

# --- 2. æœºæ¢°è‡‚æ§åˆ¶ç±» (Arm Class) ---
class Arm:
    x0 = 240.9
    y0 = -11.2
    z0 = -10
    device = None

    def __init__(self):
        ports = list_ports.comports()
        if not ports:
            raise Exception("æœªæ‰¾åˆ°ä¸²å£è®¾å¤‡ï¼Œè¯·æ£€æŸ¥æœºæ¢°è‡‚è¿æ¥")
        port = ports[0].device
        self.device = Dobot(port=port, verbose=False)

    def reset(self):
        """
        ä¸¥æ ¼ä¿ç•™æ ¡å‡†ä¸é¿è®©åºåˆ—
        """
        self.device.move_to(self.x0, self.y0, self.z0, 0, wait=True)
        self.device.move_to(self.x0, -79.3, self.z0, 0, wait=True)
        self.device.move_to(self.x0, 79.6, self.z0, 0, wait=True)
        self.device.move_to(self.x0, self.y0, self.z0, 0, wait=True)
        self.device.move_to(202.9, self.y0, -5, 0, wait=True)
        self.device.move_to(296.7, self.y0, -15, 0, wait=True)

    def act(self, board, move):
        """æ‰§è¡ŒåŠ¨ä½œï¼šå¤„ç†åƒå­ã€æ˜“ä½ã€æ™®é€šç§»åŠ¨"""
        x1 = move.from_square // 8
        y1 = 7 - (move.from_square % 8)
        x2 = move.to_square // 8
        y2 = 7 - (move.to_square % 8)

        if board.is_capture(move):
            self._move_piece(x2, y2, 3, -3)
        
        if board.is_kingside_castling(move):
            self._move_piece(x1, y1, x2, y2)
            self._move_piece(x1, 0, x1, 2)
        elif board.is_queenside_castling(move):
            self._move_piece(x1, y1, x2, y2)
            self._move_piece(x1, 7, x1, 4)
        else:
            self._move_piece(x1, y1, x2, y2)

    def _move_piece(self, x1, y1, x2, y2):
        if x1 > 4:
            dx, dy, dz, dz2 = 18.6, 22.5, 15, -17
        else:
            dx, dy, dz, dz2 = 19.0, 22.7, 10, -10

        self.device.move_to(self.x0, self.y0, self.z0 + dz, 0, wait=True)
        self.device.move_to(self.x0 + (x1 - 3) * dx, self.y0 + (y1 - 3) * dy, self.z0 + dz, 0, wait=True)
        self.device.move_to(self.x0 + (x1 - 3) * dx, self.y0 + (y1 - 3) * dy, self.z0 + dz2, 0, wait=True)
        self.device.suck(True)
        self.device.move_to(self.x0 + (x1 - 3) * dx, self.y0 + (y1 - 3) * dy, self.z0 + dz, 0, wait=True)

        if x2 > 4:
            dx, dy, dz, dz2 = 18.6, 22.5, 15, -15
        else:
            dx, dy, dz, dz2 = 19.0, 22.7, 10, -10

        self.device.move_to(self.x0 + (x2 - 3) * dx, self.y0 + (y2 - 3) * dy, self.z0 + dz, 0, wait=True)
        self.device.move_to(self.x0 + (x2 - 3) * dx, self.y0 + (y2 - 3) * dy, self.z0 + dz2, 0, wait=True)
        self.device.suck(False)
        self.device.move_to(self.x0 + (x2 - 3) * dx, self.y0 + (y2 - 3) * dy, self.z0 + dz, 0, wait=True)
        self.device.move_to(self.x0 + (2 - 3) * dx, self.y0 + (-3 - 3) * dy, self.z0 + dz, 0, wait=True)

# --- 3. è¾…åŠ©åŠŸèƒ½ä¸æŒ‡ç¤ºè¾“å‡º ---
Square = namedtuple("Square", ["x", "y"])

def get_internal_position(board):
    res = []
    for x in range(8):
        row = []
        for y in range(8):
            piece = board.piece_at(chess.square(7-y, x))
            if piece is None: row.append(SquareType.empty)
            elif piece.color == chess.WHITE: row.append(SquareType.white)
            else: row.append(SquareType.black)
        res.append(tuple(row))
    return tuple(res)

def matrix_to_uci(square):
    files = "hgfedcba"
    ranks = "12345678"
    return files[square.y] + ranks[square.x]

def print_debug_board(position):
    print("    " + " ".join(["h","g","f","e","d","c","b","a"]))
    for x in reversed(range(8)):
        row_str = f"{x+1} |"
        for y in range(8):
            val = str(position[x][y]).split('.')[-1][0] 
            row_str += f" {val}"
        print(row_str + f" | {x+1}")
    print("    " + " ".join(["h","g","f","e","d","c","b","a"]))

# --- 4. ä¸»é€»è¾‘ ---
def main():
    video_widget = widgets.Image(format='jpeg', width=width, height=height)
    debug_output = widgets.Output(layout={'border': '1px solid gray', 'height': '420px', 'overflow_y': 'scroll'})
    status_label = widgets.Label(value="ğŸŸ¢ åˆå§‹åŒ–ç¡¬ä»¶ä¸­...")
    suggestion_box = widgets.HTML(value="<b>ğŸ¤– AI å»ºè®®:</b> ç­‰å¾…å¼€å±€...")
    
    display(widgets.VBox([
        status_label,
        suggestion_box,
        widgets.HBox([video_widget, debug_output])
    ]))

    cap = cv2.VideoCapture(0)
    board = chess.Board()
    frame_counter = 0
    
    try:
        arm = Arm()
        status_label.value = "ğŸ¦¾ æœºæ¢°è‡‚æ­£åœ¨æ‰§è¡Œåˆå§‹åŒ–è·¯å¾„ (é¿è®©æ‘„åƒå¤´)..."
        arm.reset() 
        arm.device.move_to(221.9, -141.34, 15, 0, wait=True)
        with debug_output: print("âœ… æœºæ¢°è‡‚å·²ç§»è‡³é¿è®©ä½ç½®")
        
        engine = chess.engine.SimpleEngine.popen_uci(SF_PATH)
        with debug_output: print("âœ… Stockfish åŠ è½½æˆåŠŸ")
    except Exception as e:
        with debug_output: print(f"âŒ å¯åŠ¨å¤±è´¥: {e}")
        return

    current_logic_pos = get_internal_position(board)
    last_seen_pos = None
    stable_count = 0
    STABLE_THRESHOLD = 15

    status_label.value = "ğŸŸ¢ ç³»ç»Ÿå°±ç»ªï¼Œè¯·ç™½æ–¹èµ°å­"

    try:
        while True:
            ret, frame = cap.read()
            if not ret: break
            frame_counter += 1

            _, buffer = cv2.imencode('.jpg', frame)
            video_widget.value = buffer.tobytes()

            try:
                vision_pos, _ = get_position_from_image(frame)
                vision_pos = tuple(tuple(r) for r in vision_pos)

                if frame_counter % 30 == 0:
                    with debug_output:
                        clear_output(wait=True)
                        print(f"--- å¸§: {frame_counter} å®æ—¶è¯†åˆ«ç»“æœ ---")
                        print_debug_board(vision_pos)
                        print(f"å½“å‰è½®åˆ°: {'ç™½' if board.turn else 'é»‘'} æ–¹")

                # --- æ ¸å¿ƒä¿®æ”¹ï¼šèµ°å­æ£€æµ‹æ˜¾ç¤ºå˜åŒ–æ ¼æ•° ---
                if vision_pos != current_logic_pos:
                    # è®¡ç®—å½“å‰è¯†åˆ«åˆ°çš„å˜åŒ–æ ¼æ•°
                    diffs_now = [Square(x, y) for x in range(8) for y in range(8) 
                                 if current_logic_pos[x][y] != vision_pos[x][y]]
                    num_diffs = len(diffs_now)

                    if vision_pos == last_seen_pos:
                        stable_count += 1
                        # ã€åœ¨æ­¤å¤„æ·»åŠ äº†â€œæ£€æµ‹åˆ° N ä¸ªå˜åŒ–â€ã€‘
                        status_label.value = f"â³ æ£€æµ‹åˆ° {num_diffs} ä¸ªå˜åŒ– ({stable_count})"
                    else:
                        stable_count = 0
                        last_seen_pos = vision_pos
                        status_label.value = f"ğŸ‘€ è¯†åˆ«åˆ° {num_diffs} ä¸ªæ ¼å­åœ¨åŠ¨..."
                    
                    if stable_count >= STABLE_THRESHOLD:
                        # ç¨³å®šåçš„é€»è¾‘
                        diffs = diffs_now
                        
                        if len(diffs) >= 2:
                            starts = [p for p in diffs if vision_pos[p.x][p.y] == SquareType.empty]
                            if starts:
                                start = starts[0]
                                end = [p for p in diffs if p != start][0]
                                move_uci = matrix_to_uci(start) + matrix_to_uci(end)
                                
                                try:
                                    move = chess.Move.from_uci(move_uci)
                                    if move in board.legal_moves:
                                        board.push(move)
                                        with debug_output: print(f"ğŸ¯ æˆåŠŸè¯†åˆ«ç§»åŠ¨: {move_uci}")
                                        
                                        status_label.value = "ğŸ¤– AI æ€è€ƒä¸­å¹¶æ“ä½œæœºæ¢°è‡‚..."
                                        result = engine.play(board, chess.engine.Limit(time=1.0))
                                        ai_move = result.move
                                        
                                        # æœºæ¢°è‡‚æ“ä½œ
                                        arm.reset()
                                        arm.act(board, ai_move)
                                        
                                        board.push(ai_move)
                                        current_logic_pos = get_internal_position(board)
                                        
                                        suggestion_box.value = f"<b>ğŸ¤– AI ä¸Šä¸€æ­¥åŠ¨ä½œ:</b> {ai_move}"
                                        status_label.value = "âœ… è¯·èµ°å­..."
                                    else:
                                        status_label.value = f"âš ï¸ éæ³•åŠ¨ä½œ: {move_uci}"
                                except Exception as e:
                                    with debug_output: print(f"è§£æé”™è¯¯: {e}")
                        stable_count = 0
                else:
                    stable_count = 0

            except ChessboardNotFoundError:
                status_label.value = "ğŸ” æœªæ‰¾åˆ°æ£‹ç›˜..."
            
            time.sleep(0.01)

    finally:
        cap.release()
        engine.quit()

if __name__ == "__main__":
    main()
