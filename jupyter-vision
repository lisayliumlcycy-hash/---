from enum import Enum
from collections import namedtuple
import cv2
import numpy as np
from io import BytesIO
import ipywidgets as widgets
from IPython.display import display, clear_output
import time

# --- 1. CONFIGURATION (Optimized for Speed) ---

# å›¾åƒå°ºå¯¸ (å·²é™ä½åˆ†è¾¨ç‡ä»¥æé«˜é€Ÿåº¦)
width, height = 320, 240

# ğŸ¯ å‡†ç¡®é˜ˆå€¼ (æ ¹æ®ç”¨æˆ·è°ƒè¯•ç»“æœç¡®å®š)
DEFAULT_WHITE_THRESHOLD = 109 
DEFAULT_BLACK_THRESHOLD = 120 
DEFAULT_CUT_MARGIN = 0 

# é¢œè‰²å¸¸é‡ (å·²æ›´æ–°)
YELLOW_LOWER = (21, 147, 111)  # ä½¿ç”¨æ‚¨è°ƒè¯•çš„æœ€ä½³å€¼
YELLOW_UPPER = (41, 255, 255)  # ä½¿ç”¨æ‚¨è°ƒè¯•çš„æœ€ä½³å€¼

# æ£‹ç›˜è§’ç‚¹é¢œè‰²æ©ç  (Red, Green, Blue, Purple)
CORNER_MASKS_HSV = [
    ((0, 140, 102), (15, 255, 255)),     # 0: çº¢è‰²
    ((62, 75, 50), (82, 255, 255)),      # 1: ç»¿è‰²
    ((96, 140, 95), (116, 255, 255)),    # 2: è“è‰² (Updated)
    ((125, 50, 50), (145, 255, 255)),    # 3: ç´«è‰²
]

# --- 2. BASE CLASSES AND EXCEPTIONS ---

Point = namedtuple("Point", ["x", "y"])

class Colors(Enum):
    white = (255, 255, 255)
    black = (0, 0, 0)
    blue = (255, 0, 0)
    green = (0, 255, 0)
    red = (0, 0, 255)

class SquareType(Enum):
    empty = 0
    white = 1
    black = 2

    def __str__(self):
        if self == SquareType.empty:
            return ' '
        if self == SquareType.white:
            return 'o'
        if self == SquareType.black:
            return 'x'
        return None

class ChessboardNotFoundError(Exception):
    """å½“æ— æ³•æ‰¾åˆ°æ£‹ç›˜è§’ç‚¹æ—¶å¼•å‘æ­¤å¼‚å¸¸"""
    pass

# --- 3. HELPER FUNCTIONS (Function names are preserved) ---

def _clean_mask(mask, kernel_size=(5, 5)):
    """ä½¿ç”¨å½¢æ€å­¦æ“ä½œæ¸…ç†æ©ç """
    kernel = np.ones(kernel_size, np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel) 
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
    return mask

def _threshold_image(image):
    """å¯¹å›¾åƒè¿›è¡Œæ¨¡ç³Šå’ŒäºŒå€¼åŒ–"""
    blurred = cv2.blur(image, (10, 10))
    _, thresholded = cv2.threshold(blurred, 200, 255, cv2.THRESH_BINARY)
    return thresholded

def _find_point(image):
    """ä»æœ€å¤§è½®å»“ä¸­æå–ä¸­å¿ƒç‚¹"""
    def center(contour):
        x, y, w, h = cv2.boundingRect(contour)
        return Point(x + w // 2, y + h // 2)

    try:
        # OpenCV 4.x returns two values
        contours, _ = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    except:
        # OpenCV 3.x returns three values
        _, contours, _ = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if len(contours) < 1:
        return None
    contour = max(contours, key=cv2.contourArea)
    return center(contour)

# Returns the four corners of the chessboard, or None if not found.
def find_corners(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    
    # åˆ›å»ºè§’ç‚¹é¢œè‰²æ©ç 
    masks = [cv2.inRange(hsv, lower, upper) for lower, upper in CORNER_MASKS_HSV]
    
    # æŸ¥æ‰¾æ¯ä¸ªæ©ç å¯¹åº”çš„ä¸­å¿ƒç‚¹
    points = [_find_point(_threshold_image(_clean_mask(mask))) for mask in masks]

    if not all(points):
        return None

    # ä» Point å¯¹è±¡ä¸­æå–åæ ‡
    x0, y0 = points[0]
    x1, y1 = points[1]
    x2, y2 = points[2]
    x3, y3 = points[3]

    # åº”ç”¨å¾®è°ƒä»¥ä¿®æ­£æ ‡è®°å’Œæ£‹ç›˜è¾¹ç¼˜çš„åå·®
    adjusted_points = [
        Point(int(x0 + (x0 - x1) * 0.00 - (x0 - x2) * 0.05), int(y0 + (y0 - y1) * 0.00 - (y0 - y2) * 0.05)),
        Point(int(x1 + (x1 - x0) * 0.08 - (x1 - x3) * 0.05), int(y1 + (y1 - y0) * 0.08 - (y1 - y3) * 0.05)),
        Point(int(x2 + (x2 - x3) * 0.02 - (x2 - x0) * 0.05), int(y2 + (y2 - y3) * 0.02 - (y2 - y0) * 0.05)),
        Point(int(x3 + (x3 - x2) * 0.08 - (x3 - x1) * 0.05), int(y3 + (y3 - y2) * 0.08 - (y3 - y1) * 0.05)),
    ]
    return adjusted_points


# Returns a new image after a perspective transform,
# moving [corners] to the corners of the image.
def transform(image, corners):
    src = np.array(
        [(corners[0].x, corners[0].y), (corners[1].x, corners[1].y), (corners[2].x, corners[2].y), (corners[3].x, corners[3].y)], np.float32)

    dst = np.array(
        [(0, 0), (width, 0), (0, height), (width, height)], np.float32)

    matrix = cv2.getPerspectiveTransform(src, dst)
    return cv2.warpPerspective(image, matrix, (width, height))


# Return the square type of the given of image.
# ------------------------------------------------------------------------------
# ğŸ¯ äº¤äº’å¼æ£‹å­æ£€æµ‹å‡½æ•°
# ------------------------------------------------------------------------------
def detect_square_type(image_gray, image_hsv):
    """
    ä½¿ç”¨æ¥è‡ª Jupyter æ»‘å—çš„å®æ—¶é˜ˆå€¼è¯†åˆ«æ£‹æ ¼ç±»å‹ã€‚
    """
    
    # ä»æ»‘å—å®æ—¶è¯»å–æœ€æ–°çš„é˜ˆå€¼
    white_thresh = W_TH_SLIDER.value
    black_thresh = B_TH_SLIDER.value
    yellow_lower = (Y_H_LOW_SLIDER.value, YELLOW_LOWER[1], YELLOW_LOWER[2]) # S, V ä½¿ç”¨é»˜è®¤å€¼
    yellow_upper = (Y_H_HIGH_SLIDER.value, YELLOW_UPPER[1], YELLOW_UPPER[2]) # S, V ä½¿ç”¨é»˜è®¤å€¼
    
    # ROI æˆªå–ï¼ˆä»…æˆªå–ä¸­å¿ƒ 40%ï¼‰
    h, w = image_gray.shape
    roi_gray = image_gray[int(h*0.3):int(h*0.7), int(w*0.3):int(w*0.7)] 
    roi_hsv = image_hsv[int(h*0.3):int(h*0.7), int(w*0.3):int(w*0.7)] 
    
    mean_val = np.mean(roi_gray) 
    square_type = SquareType.empty
    
    # 1. é¢œè‰²è¿‡æ»¤æ£€æµ‹ç©ºä½ (é»„è‰²èƒŒæ™¯)
    yellow_mask = cv2.inRange(roi_hsv, yellow_lower, yellow_upper)
    # é»„è‰²æ£€æµ‹æ—¶ï¼ŒSå’ŒVçš„ä½é˜ˆå€¼åº”è¯¥æ¥è¿‘0ï¼Œä»¥æ£€æµ‹è¾ƒæ·¡çš„é»„è‰²ã€‚
    # è¿™ä¸€æ­¥ä½¿ç”¨ S/V çš„é»˜è®¤å€¼ï¼Œä¸»è¦è°ƒæ•´ Hã€‚
    yellow_ratio = cv2.countNonZero(yellow_mask) / roi_gray.size
    
    if yellow_ratio > 0.50: 
        square_type = SquareType.empty
    
    # 2. äº®åº¦é˜ˆå€¼åŒºåˆ†æ£‹å­
    else:
        # æ³¨æ„ï¼šè¿™é‡Œçš„é€»è¾‘åº”è¯¥æ˜¯ï¼š
        # å¦‚æœäº®åº¦æé«˜ï¼Œåˆ™ä¸ºç™½å­ï¼›
        # å¦‚æœäº®åº¦æä½ï¼Œåˆ™ä¸ºé»‘å­ï¼›
        # ä»‹äºä¸¤è€…ä¹‹é—´ï¼Œå¯èƒ½æ˜¯æœªè¢«é»„è‰²æ£€æµ‹åˆ°çš„ç©ºä½æˆ–èƒŒæ™¯å¹²æ‰°ã€‚
        
        # ä¿®æ­£æ‚¨çš„åŸå§‹é€»è¾‘ï¼šç™½å­é˜ˆå€¼åº”é«˜äºé»‘å­é˜ˆå€¼
        if mean_val > white_thresh: 
            square_type = SquareType.white
        elif mean_val < black_thresh:
            square_type = SquareType.black
        else:
            square_type = SquareType.empty
            
    return square_type


# ------------------------------------------------------------------------------
# ğŸ¯ ä¸»å‡½æ•° GET_POSITION_FROM_IMAGE
# ------------------------------------------------------------------------------

def get_position_from_image(image):
    """
    è¯†åˆ«å›¾åƒä¸­çš„æ£‹ç›˜ï¼Œå¹¶è¿”å›å¯¹åº”çš„ 8x8 SquareType é˜µåˆ—ã€‚
    
    Args:
        image: åŸå§‹ OpenCV BGR å›¾åƒå¸§ã€‚
        
    Returns:
        list[list[SquareType]]: 8x8 æ£‹ç›˜çŠ¶æ€ã€‚
        
    Raises:
        ChessboardNotFoundError: å¦‚æœæ— æ³•æ‰¾åˆ°è§’ç‚¹ã€‚
    """
    
    # 1. è£å‰ªè¾…åŠ©å‡½æ•°
    def crop(image, i, j, margin_px): 
        w_sq = int(width / 8)
        h_sq = int(height / 8)
        
        x_start = w_sq * i
        x_end = w_sq * (i + 1)
        y_start = h_sq * j
        y_end = h_sq * (j + 1)
        
        return image[y_start + margin_px : y_end - margin_px, 
                     x_start + margin_px : x_end - margin_px]

    # 2. ç¼©æ”¾è¾“å…¥å›¾åƒåˆ°ç›®æ ‡å¤„ç†åˆ†è¾¨ç‡ (320x240)
    image = cv2.resize(image, (width, height))
    
    # 3. å¯»æ‰¾è§’ç‚¹å¹¶è¿›è¡Œé€è§†å˜æ¢
    corners = find_corners(image)
    if corners is None:
        raise ChessboardNotFoundError()

    chessboard_image = transform(image, corners)
    
    # 4. é¢„è½¬æ¢é¢œè‰²ç©ºé—´ (ä»…æ‰§è¡Œä¸¤æ¬¡ï¼Œæå‡æ€§èƒ½)
    chessboard_gray = cv2.cvtColor(chessboard_image, cv2.COLOR_BGR2GRAY)
    chessboard_hsv = cv2.cvtColor(chessboard_image, cv2.COLOR_BGR2HSV)
    
    margin_px = DEFAULT_CUT_MARGIN

    position = []
    
    # 5. éå† 8x8 æ£‹æ ¼å¹¶è¯†åˆ«
    for j in range(8):
        row = []
        for i in range(8):
            # è£å‰ª Gray å’Œ HSV å›¾åƒåˆ‡ç‰‡
            cropped_gray = crop(chessboard_gray, i, j, margin_px)
            cropped_hsv = crop(chessboard_hsv, i, j, margin_px)
            
            # ä¼ å…¥é¢„è½¬æ¢çš„åˆ‡ç‰‡è¿›è¡Œå¿«é€Ÿè¯†åˆ«
            square_type = detect_square_type(cropped_gray, cropped_hsv)
            
            row.append(square_type)

        position.append(row)

    return position, chessboard_image  # è¿”å›æ£‹ç›˜å›¾åƒç”¨äºæ˜¾ç¤º


# ------------------------------------------------------------------------------
# ğŸ“¢ Jupyter ä¸“ç”¨ç‰ˆæœ¬
# ------------------------------------------------------------------------------

# åˆ›å»ºæ˜¾ç¤ºéƒ¨ä»¶
original_widget = widgets.Image(format='jpeg', width=width, height=height)
chessboard_widget = widgets.Image(format='jpeg', width=width, height=height)
# --- 1. å®šä¹‰äº¤äº’å¼æ»‘å— Widgets (ç”¨äºæ£‹å­æ£€æµ‹) ---

# ç™½å­ç°åº¦é˜ˆå€¼ (é«˜äºæ­¤å€¼ä¸ºç™½å­)
W_TH_SLIDER = widgets.IntSlider(
    value=110, min=50, max=250, step=1,
    description='ç™½å­é˜ˆå€¼:',
    layout=widgets.Layout(width='300px'), style={'description_width': 'initial'}
)

# é»‘å­ç°åº¦é˜ˆå€¼ (ä½äºæ­¤å€¼ä¸ºé»‘å­)
B_TH_SLIDER = widgets.IntSlider(
    value=150, min=50, max=250, step=1,
    description='é»‘å­é˜ˆå€¼:',
    layout=widgets.Layout(width='300px'), style={'description_width': 'initial'}
)

# é»„è‰² H ä¸‹é™ (ç”¨äºç©ºä½æ£€æµ‹)
Y_H_LOW_SLIDER = widgets.IntSlider(
    value=26, min=0, max=180, step=1,
    description='é»„Hä¸‹é™:',
    layout=widgets.Layout(width='300px'), style={'description_width': 'initial'}
)

# é»„è‰² H ä¸Šé™ (ç”¨äºç©ºä½æ£€æµ‹)
Y_H_HIGH_SLIDER = widgets.IntSlider(
    value=46, min=0, max=180, step=1,
    description='é»„Hä¸Šé™:',
    layout=widgets.Layout(width='300px'), style={'description_width': 'initial'}
)

# ç»„åˆæ»‘å—è¿›è¡Œæ˜¾ç¤º
detection_sliders = widgets.VBox([
    widgets.Label("â™Ÿï¸ æ£‹å­æ£€æµ‹å®æ—¶è°ƒè¯• (ç°åº¦åŸºäº 0-255, HSV HåŸºäº 0-180)"),
    widgets.HBox([W_TH_SLIDER, B_TH_SLIDER]),
    widgets.HBox([Y_H_LOW_SLIDER, Y_H_HIGH_SLIDER])
])

# å°†æ»‘å—æ˜¾ç¤ºåœ¨æœ€å‰é¢ (æˆ–è€…æ‚¨é€‰æ‹©çš„ä»»ä½•ä½ç½®)
display(detection_sliders)
output_area = widgets.Output()

# æ˜¾ç¤ºéƒ¨ä»¶
display(widgets.HBox([widgets.VBox([
    widgets.Label("åŸå§‹å›¾åƒ"),
    original_widget
]), widgets.VBox([
    widgets.Label("çŸ«æ­£åæ£‹ç›˜"),
    chessboard_widget
])]))
display(output_area)

# æ‘„åƒå¤´åˆå§‹åŒ–
CAMERA_INDEX = 0
cap = cv2.VideoCapture(CAMERA_INDEX)

if not cap.isOpened():
    print(f"âŒ æ— æ³•æ‰“å¼€æ‘„åƒå¤´ (ç´¢å¼• {CAMERA_INDEX})")
    exit()

print(f"âœ… æ‘„åƒå¤´å·²æ‰“å¼€")
print(f"ğŸ“ å¤„ç†åˆ†è¾¨ç‡: {width}x{height}")
print("ğŸ”„ æ­£åœ¨å¯åŠ¨... (æŒ‰åœæ­¢æŒ‰é’®ä¸­æ–­)")

frame_counter = 0
is_running = True

def stop_capture(change):
    global is_running
    is_running = False
    print("ğŸ›‘ ç”¨æˆ·ä¸­æ–­")

# åˆ›å»ºåœæ­¢æŒ‰é’®
stop_button = widgets.Button(description="åœæ­¢")
stop_button.on_click(stop_capture)
display(stop_button)

try:
    while is_running:
        # è¯»å–æ‘„åƒå¤´å¸§
        ret, frame = cap.read()
        if not ret:
            print("âŒ æ— æ³•è¯»å–å¸§")
            break
        
        # æ˜¾ç¤ºåŸå§‹å›¾åƒ
        _, buffer_original = cv2.imencode(".jpg", cv2.resize(frame, (width, height)))
        original_widget.value = buffer_original.tobytes()
        
        # æ¯30å¸§å¤„ç†ä¸€æ¬¡æ£‹ç›˜è¯†åˆ«
        if frame_counter % 30 == 0:
            with output_area:
                clear_output(wait=True)
                try:
                    # è¯†åˆ«æ£‹ç›˜
                    position, chessboard_img = get_position_from_image(frame)
                    
                    # æ˜¾ç¤ºçŸ«æ­£åçš„æ£‹ç›˜å›¾åƒ
                    _, buffer_chessboard = cv2.imencode(".jpg", chessboard_img)
                    chessboard_widget.value = buffer_chessboard.tobytes()
                    
                    # è¾“å‡ºæ£‹ç›˜çŠ¶æ€
                    print(f"ğŸ“Š ç¬¬ {frame_counter} å¸§ - æ£‹ç›˜çŠ¶æ€:")
                    print("+" + "-" * 8 + "+")
                    for row in position:
                        row_str = "|" + "".join([str(p) for p in row]) + "|"
                        print(row_str)
                    print("+" + "-" * 8 + "+")
                    
                except ChessboardNotFoundError:
                    print(f"ç¬¬ {frame_counter} å¸§: âš ï¸ æœªæ£€æµ‹åˆ°æ£‹ç›˜è§’ç‚¹")
                except Exception as e:
                    print(f"ç¬¬ {frame_counter} å¸§: âŒ é”™è¯¯: {e}")
        
        frame_counter += 1
        time.sleep(0.033)  # å¤§çº¦30fps

except Exception as e:
    print(f"âŒ ç¨‹åºé”™è¯¯: {e}")
finally:
    cap.release()
    print("âœ… æ‘„åƒå¤´å·²é‡Šæ”¾")
    print("ğŸ¯ ç¨‹åºç»“æŸ")
