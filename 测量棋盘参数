import time
from pydobot import Dobot
import json
import os
from IPython.display import display, clear_output
import ipywidgets as widgets

# æ£‹ç›˜æ ‡å®šç»“æœä¿å­˜æ–‡ä»¶
CALIBRATION_FILE = "chessboard_calibration.json"

class SuctionArm:
    def __init__(self, port='/dev/ttyUSB0', verbose=True):
        self.port = port
        self.verbose = verbose
        self.dobot = None
        self.is_connected = False
        
        # è¿åŠ¨å‚æ•°
        self.move_speed = 50
        self.move_distance = 10  # å•æ¬¡ç§»åŠ¨è·ç¦»(mm)
        self.fine_move_distance = 2  # ç²¾ç»†ç§»åŠ¨è·ç¦»(mm)
        
        # å¸ç›˜å‚æ•°
        self.suction_duration = 1.0
        self.lift_height = 80
        self.pick_height = 3
        self.approach_speed = 50
        
        # æ£‹ç›˜æ ‡å®šæ•°æ®
        self.board_calibrated = False
        self.square_size = 0
        self.board_origin = None
        self.board_z = 0
        
        self.home_position = (200, 0, 100, 0)
        
        self.connect()
        self.load_calibration()
        
        # åˆ›å»ºæ§åˆ¶ç•Œé¢
        self.create_control_panel()

    def connect(self):
        try:
            self.dobot = Dobot(port=self.port, verbose=self.verbose)
            self.is_connected = True
            print(f"âœ… æˆåŠŸè¿æ¥åˆ°æœºæ¢°è‡‚ï¼Œç«¯å£: {self.port}")
        except Exception as e:
            print(f"âŒ è¿æ¥æœºæ¢°è‡‚å¤±è´¥: {e}")
            self.is_connected = False

    def disconnect(self):
        if self.dobot:
            self.dobot.close()
            self.is_connected = False
            print("ğŸ”Œ æœºæ¢°è‡‚å·²æ–­å¼€è¿æ¥")

    def set_suction(self, enable=True):
        """æ§åˆ¶å¸ç›˜"""
        if not self.is_connected:
            print("âŒ æœºæ¢°è‡‚æœªè¿æ¥")
            return False
        
        self.dobot.suck(enable)
        time.sleep(0.5)
        if enable:
            print("ğŸ§² å¸ç›˜å¼€å¯")
        else:
            print("ğŸ”“ å¸ç›˜å…³é—­")
        return True

    def get_current_position(self):
        """è·å–å½“å‰ä½ç½®åæ ‡"""
        if not self.is_connected:
            print("âŒ æœºæ¢°è‡‚æœªè¿æ¥")
            return None
        return self.dobot.pose()

    def move_relative(self, dx=0, dy=0, dz=0):
        """ç›¸å¯¹ç§»åŠ¨"""
        if not self.is_connected:
            print("âŒ æœºæ¢°è‡‚æœªè¿æ¥")
            return False
        
        current_pos = self.get_current_position()
        if current_pos:
            new_x = current_pos[0] + dx
            new_y = current_pos[1] + dy
            new_z = current_pos[2] + dz
            
            print(f"â¡ï¸  ç§»åŠ¨: X{dx:+.1f}, Y{dy:+.1f}, Z{dz:+.1f}")
            self.dobot.move_to(new_x, new_y, new_z, current_pos[3], wait=True)
            self.update_status()
            return True
        return False

    def move_to_safe(self, x, y, z, r=0):
        """å®‰å…¨ç§»åŠ¨åˆ°æŒ‡å®šä½ç½®"""
        if not self.is_connected:
            print("âŒ æœºæ¢°è‡‚æœªè¿æ¥")
            return False
        
        current_pos = self.dobot.pose()
        self.dobot.move_to(current_pos[0], current_pos[1], self.lift_height, r, wait=True)
        self.dobot.move_to(x, y, self.lift_height, r, wait=True)
        self.dobot.move_to(x, y, z, r, wait=True)
        self.update_status()
        return True

    def chess_square_to_xyz(self, file, rank):
        """å°†æ£‹ç›˜æ ¼å­è½¬æ¢ä¸ºåæ ‡"""
        if not self.board_calibrated:
            print("âŒ é”™è¯¯ï¼šæ£‹ç›˜æœªæ ‡å®šï¼")
            return None
            
        col = ord(file) - ord('a')
        row = 8 - rank
        
        x = self.board_origin[0] + col * self.square_size + self.square_size / 2
        y = self.board_origin[1] + row * self.square_size + self.square_size / 2
        z = self.board_z + self.pick_height
        
        return (x, y, z)

    def move_to_chess_square(self, square_name, lift_first=True):
        """ç§»åŠ¨åˆ°æŒ‡å®šæ£‹ç›˜æ ¼å­"""
        if len(square_name) != 2:
            print("âŒ é”™è¯¯ï¼šæ ¼å­æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º a1-h8")
            return False
            
        file = square_name[0].lower()
        rank = int(square_name[1])
        
        if file < 'a' or file > 'h' or rank < 1 or rank > 8:
            print("âŒ é”™è¯¯ï¼šæ ¼å­è¶…å‡ºèŒƒå›´")
            return False
            
        coord = self.chess_square_to_xyz(file, rank)
        if not coord:
            return False
            
        x, y, z = coord
        print(f"ğŸ¯ ç§»åŠ¨åˆ°æ ¼å­ {square_name.upper()} â†’ ({x:.1f}, {y:.1f}, {z:.1f})")
        
        if lift_first:
            self.move_to_safe(x, y, z + 30)
        self.dobot.move_to(x, y, z, 0, wait=True)
        time.sleep(0.5)
        self.update_status()
        return True

    def save_calibration(self):
        """ä¿å­˜æ ‡å®šæ•°æ®"""
        data = {
            "square_size": self.square_size,
            "board_origin_x": self.board_origin[0],
            "board_origin_y": self.board_origin[1],
            "board_z": self.board_z,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        with open(CALIBRATION_FILE, "w") as f:
            json.dump(data, f, indent=2)
        print(f"ğŸ’¾ æ ‡å®šæ•°æ®å·²ä¿å­˜åˆ° {CALIBRATION_FILE}")

    def load_calibration(self):
        """åŠ è½½æ ‡å®šæ•°æ®"""
        if not os.path.exists(CALIBRATION_FILE):
            return False
        try:
            with open(CALIBRATION_FILE) as f:
                data = json.load(f)
            self.square_size = data["square_size"]
            self.board_origin = (data["board_origin_x"], data["board_origin_y"], self.board_z)
            self.board_z = data["board_z"]
            self.board_calibrated = True
            print(f"ğŸ“‚ æ ‡å®šæ•°æ®åŠ è½½æˆåŠŸï¼æ ¼å­è¾¹é•¿ = {self.square_size}mm")
            return True
        except Exception as e:
            print(f"âŒ åŠ è½½æ ‡å®šå¤±è´¥: {e}")
            return False

    def create_control_panel(self):
        """åˆ›å»ºå›¾å½¢åŒ–æ§åˆ¶é¢æ¿"""
        # çŠ¶æ€æ˜¾ç¤º
        self.status_label = widgets.Label(value="ç­‰å¾…è¿æ¥...")
        
        # ç§»åŠ¨è·ç¦»æ§åˆ¶
        self.distance_slider = widgets.IntSlider(
            value=self.move_distance,
            min=1,
            max=50,
            step=1,
            description='ç§»åŠ¨è·ç¦»:',
            continuous_update=False
        )
        
        # æ–¹å‘æ§åˆ¶æŒ‰é’®
        button_style = {'button_color': 'lightblue', 'font_weight': 'bold'}
        
        self.btn_up = widgets.Button(description='â¬†ï¸ å‰', layout=widgets.Layout(width='80px'), **button_style)
        self.btn_down = widgets.Button(description='â¬‡ï¸ å', layout=widgets.Layout(width='80px'), **button_style)
        self.btn_left = widgets.Button(description='â¬…ï¸ å·¦', layout=widgets.Layout(width='80px'), **button_style)
        self.btn_right = widgets.Button(description='â¡ï¸ å³', layout=widgets.Layout(width='80px'), **button_style)
        self.btn_up_z = widgets.Button(description='ğŸ”¼ ä¸Š', layout=widgets.Layout(width='80px'), **button_style)
        self.btn_down_z = widgets.Button(description='ğŸ”½ ä¸‹', layout=widgets.Layout(width='80px'), **button_style)
        
        # åŠŸèƒ½æŒ‰é’®
        self.btn_suction = widgets.Button(description='ğŸ§² å¸ç›˜å¼€å…³', layout=widgets.Layout(width='120px'))
        self.btn_home = widgets.Button(description='ğŸ  å›å®¶', layout=widgets.Layout(width='120px'))
        self.btn_safe = widgets.Button(description='ğŸ›¡ï¸ å®‰å…¨é«˜åº¦', layout=widgets.Layout(width='120px'))
        self.btn_status = widgets.Button(description='ğŸ“Š åˆ·æ–°çŠ¶æ€', layout=widgets.Layout(width='120px'))
        
        # æ ‡å®šæ§åˆ¶
        self.calibration_point = widgets.Dropdown(
            options=['a1', 'h1', 'a8', 'h8', 'e4'],
            value='a1',
            description='æ ‡å®šç‚¹:',
            layout=widgets.Layout(width='200px')
        )
        self.btn_record = widgets.Button(description='ğŸ“ è®°å½•ä½ç½®', layout=widgets.Layout(width='120px'))
        self.btn_calculate = widgets.Button(description='ğŸ“ è®¡ç®—æ ‡å®š', layout=widgets.Layout(width='120px'))
        self.btn_save_calib = widgets.Button(description='ğŸ’¾ ä¿å­˜æ ‡å®š', layout=widgets.Layout(width='120px'))
        self.btn_test = widgets.Button(description='ğŸ§ª æµ‹è¯•ç§»åŠ¨', layout=widgets.Layout(width='120px'))
        
        # æ ¼å­ç§»åŠ¨
        self.chess_square = widgets.Text(
            value='e4',
            placeholder='è¾“å…¥æ ¼å­ (å¦‚ e4)',
            description='ç›®æ ‡æ ¼å­:',
            layout=widgets.Layout(width='200px')
        )
        self.btn_move_square = widgets.Button(description='ğŸ¯ ç§»åŠ¨åˆ°æ ¼å­', layout=widgets.Layout(width='120px'))
        
        # è¿æ¥æŒ‰é’®äº‹ä»¶
        self.btn_up.on_click(lambda x: self.move_relative(dy=self.distance_slider.value))
        self.btn_down.on_click(lambda x: self.move_relative(dy=-self.distance_slider.value))
        self.btn_left.on_click(lambda x: self.move_relative(dx=-self.distance_slider.value))
        self.btn_right.on_click(lambda x: self.move_relative(dx=self.distance_slider.value))
        self.btn_up_z.on_click(lambda x: self.move_relative(dz=self.distance_slider.value))
        self.btn_down_z.on_click(lambda x: self.move_relative(dz=-self.distance_slider.value))
        
        self.btn_suction.on_click(lambda x: self.toggle_suction())
        self.btn_home.on_click(lambda x: self.go_home())
        self.btn_safe.on_click(lambda x: self.go_safe_height())
        self.btn_status.on_click(lambda x: self.update_status())
        
        self.btn_record.on_click(lambda x: self.record_calibration_point())
        self.btn_calculate.on_click(lambda x: self.calculate_calibration())
        self.btn_save_calib.on_click(lambda x: self.save_calibration())
        self.btn_test.on_click(lambda x: self.test_calibration())
        
        self.btn_move_square.on_click(lambda x: self.move_to_chess_square(self.chess_square.value))
        
        self.distance_slider.observe(self.on_distance_change, names='value')
        
        # å­˜å‚¨æ ‡å®šæ•°æ®
        self.calibration_data = {}

    def on_distance_change(self, change):
        """ç§»åŠ¨è·ç¦»æ”¹å˜æ—¶çš„å›è°ƒ"""
        self.move_distance = change['new']
        print(f"ğŸ¯ ç§»åŠ¨è·ç¦»è®¾ç½®ä¸º: {self.move_distance}mm")

    def toggle_suction(self):
        """åˆ‡æ¢å¸ç›˜çŠ¶æ€"""
        current_pos = self.get_current_position()
        if current_pos and current_pos[2] < self.lift_height:
            self.set_suction(not self.dobot.suck())
        else:
            print("âš ï¸  é«˜åº¦è¿‡é«˜ï¼Œè¯·å…ˆé™ä½é«˜åº¦å†æ“ä½œå¸ç›˜")

    def go_home(self):
        """å›åˆ°åˆå§‹ä½ç½®"""
        self.move_to_safe(*self.home_position)
        print("ğŸ  å›åˆ°åˆå§‹ä½ç½®")

    def go_safe_height(self):
        """ä¸Šå‡åˆ°å®‰å…¨é«˜åº¦"""
        current_pos = self.get_current_position()
        if current_pos:
            self.dobot.move_to(current_pos[0], current_pos[1], self.lift_height, current_pos[3], wait=True)
            print("ğŸ›¡ï¸  ä¸Šå‡åˆ°å®‰å…¨é«˜åº¦")
            self.update_status()

    def update_status(self):
        """æ›´æ–°çŠ¶æ€æ˜¾ç¤º"""
        pos = self.get_current_position()
        if pos:
            status = f"ğŸ“ å½“å‰ä½ç½®: X={pos[0]:.1f}, Y={pos[1]:.1f}, Z={pos[2]:.1f}"
            if self.board_calibrated:
                status += f" | æ£‹ç›˜å·²æ ‡å®š (æ ¼å­: {self.square_size:.1f}mm)"
            else:
                status += " | æ£‹ç›˜æœªæ ‡å®š"
            self.status_label.value = status
        else:
            self.status_label.value = "âŒ æ— æ³•è·å–ä½ç½®"

    def record_calibration_point(self):
        """è®°å½•æ ‡å®šç‚¹"""
        point_name = self.calibration_point.value
        pos = self.get_current_position()
        if pos:
            self.calibration_data[point_name] = (pos[0], pos[1])
            print(f"âœ… å·²è®°å½• {point_name.upper()} = ({pos[0]:.1f}, {pos[1]:.1f})")
            
            # æ˜¾ç¤ºå·²è®°å½•çš„æ ‡å®šç‚¹
            print("ğŸ“‹ å·²è®°å½•çš„æ ‡å®šç‚¹:")
            for point, coord in self.calibration_data.items():
                print(f"  {point.upper()}: ({coord[0]:.1f}, {coord[1]:.1f})")
        else:
            print("âŒ æ— æ³•è·å–å½“å‰ä½ç½®")

    def calculate_calibration(self):
        """è®¡ç®—æ ‡å®šå‚æ•°"""
        if len(self.calibration_data) < 2:
            print("âŒ è¯·è‡³å°‘è®°å½•2ä¸ªæ ‡å®šç‚¹")
            return
        
        print("ğŸ“Š è®¡ç®—æ ‡å®šå‚æ•°...")
        
        if 'a1' in self.calibration_data and 'h8' in self.calibration_data:
            # ä½¿ç”¨ a1 å’Œ h8 è®¡ç®—
            x_a1, y_a1 = self.calibration_data['a1']
            x_h8, y_h8 = self.calibration_data['h8']
            
            # è®¡ç®—æ ¼å­å¤§å°
            distance_x = abs(x_h8 - x_a1)
            distance_y = abs(y_h8 - y_a1)
            self.square_size = ((distance_x / 7) + (distance_y / 7)) / 2
            
            # è®¡ç®—æ£‹ç›˜åŸç‚¹
            self.board_origin = (x_a1 - self.square_size / 2, y_a1 - self.square_size / 2, 0)
            
        elif len(self.calibration_data) >= 2:
            # ä½¿ç”¨ä»»æ„ä¸¤ä¸ªç‚¹è®¡ç®—
            points = list(self.calibration_data.items())
            square1, coord1 = points[0]
            square2, coord2 = points[1]
            
            x1, y1 = coord1
            x2, y2 = coord2
            
            # è®¡ç®—æ ¼å­ç´¢å¼•å·®
            file_diff = abs(ord(square2[0]) - ord(square1[0]))
            rank_diff = abs(int(square2[1]) - int(square1[1]))
            
            if file_diff > 0:
                size_x = abs(x2 - x1) / file_diff
            else:
                size_x = 40
                
            if rank_diff > 0:
                size_y = abs(y2 - y1) / rank_diff
            else:
                size_y = 40
                
            self.square_size = (size_x + size_y) / 2
            
            # ä½¿ç”¨ç¬¬ä¸€ä¸ªç‚¹è®¡ç®—åŸç‚¹
            file_idx = ord(square1[0]) - ord('a')
            rank_idx = 8 - int(square1[1])
            self.board_origin = (x1 - file_idx * self.square_size - self.square_size/2, 
                               y1 - rank_idx * self.square_size - self.square_size/2, 0)
        
        self.board_z = self.get_current_position()[2] if self.get_current_position() else 0
        self.board_calibrated = True
        
        print(f"ğŸ‰ æ ‡å®šå®Œæˆï¼")
        print(f"ğŸ“ æ ¼å­è¾¹é•¿: {self.square_size:.2f} mm")
        print(f"ğŸ¯ æ£‹ç›˜åŸç‚¹: ({self.board_origin[0]:.1f}, {self.board_origin[1]:.1f})")
        self.update_status()

    def test_calibration(self):
        """æµ‹è¯•æ ‡å®šç»“æœ"""
        if not self.board_calibrated:
            print("âŒ è¯·å…ˆå®Œæˆæ ‡å®š")
            return
        
        test_squares = ['a1', 'e4', 'h8']
        print("ğŸ§ª æµ‹è¯•æ ‡å®šç»“æœ:")
        for square in test_squares:
            coord = self.chess_square_to_xyz(square[0], int(square[1]))
            if coord:
                print(f"  {square.upper()} â†’ ({coord[0]:.1f}, {coord[1]:.1f})")
        
        # å®é™…ç§»åŠ¨åˆ° e4 æµ‹è¯•
        self.move_to_chess_square("e4")

    def show_control_panel(self):
        """æ˜¾ç¤ºæ§åˆ¶é¢æ¿"""
        clear_output(wait=True)
        
        # åˆ›å»ºå¸ƒå±€
        move_controls = widgets.VBox([
            widgets.HBox([self.btn_up]),
            widgets.HBox([self.btn_left, self.btn_right]),
            widgets.HBox([self.btn_down]),
            widgets.HBox([self.btn_up_z, self.btn_down_z])
        ])
        
        basic_controls = widgets.VBox([
            self.btn_suction,
            self.btn_home,
            self.btn_safe,
            self.btn_status
        ])
        
        calibration_controls = widgets.VBox([
            self.calibration_point,
            widgets.HBox([self.btn_record, self.btn_calculate]),
            widgets.HBox([self.btn_save_calib, self.btn_test])
        ])
        
        chess_controls = widgets.VBox([
            self.chess_square,
            self.btn_move_square
        ])
        
        main_layout = widgets.VBox([
            self.status_label,
            self.distance_slider,
            widgets.HTML("<hr>"),
            widgets.HTML("<b>ğŸ® æ–¹å‘æ§åˆ¶:</b>"),
            widgets.HBox([move_controls, basic_controls]),
            widgets.HTML("<hr>"),
            widgets.HTML("<b>ğŸ¯ æ ‡å®šæ§åˆ¶:</b>"),
            calibration_controls,
            widgets.HTML("<hr>"),
            widgets.HTML("<b>â™Ÿï¸ æ£‹ç›˜ç§»åŠ¨:</b>"),
            chess_controls
        ])
        
        display(main_layout)
        self.update_status()


# ä½¿ç”¨ç¤ºä¾‹
def main():
    # åˆ›å»ºæœºæ¢°è‡‚å®ä¾‹
    arm = SuctionArm(port='/dev/ttyUSB0', verbose=True)
    
    if not arm.is_connected:
        print("âŒ æ— æ³•è¿æ¥æœºæ¢°è‡‚")
        return
    
    # æ˜¾ç¤ºæ§åˆ¶é¢æ¿
    arm.show_control_panel()
    
    return arm


# è¿è¡Œç¨‹åº
if __name__ == "__main__":
    arm = main()
